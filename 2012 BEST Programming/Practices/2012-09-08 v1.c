#pragma config(Sensor, in1,    pet300,         sensorPotentiometer)
#pragma config(Sensor, in4,    pet10r,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  sMotor1f,       sensorDigitalIn)
#pragma config(Sensor, dgtl2,  sMotor1r,       sensorDigitalIn)
#pragma config(Sensor, dgtl3,  sMotor2f,       sensorDigitalIn)
#pragma config(Sensor, dgtl4,  sMotor2r,       sensorDigitalIn)
#pragma config(Motor,  port2,           LeftDrive,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           sMotor1,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           servo1,        tmotorServoStandard, openLoop)
#pragma config(Motor,  port5,           servo2,        tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           servo3,        tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           servo4,        tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           sMotor2,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           RightDrive,    tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

 /********************************************************\
| Base code written by Team 176, Metro Homeschool Robotics |
 \********************************************************/


/*
	Left Drive Motor port 2
	Small Motor 1 port 3
	Four servos, ports 4-7
	Small Motor 2 port 8
	Right Drive Motor port 9, reversed
*/



int threshold = 10;

task Drive() {
  int RightX;
  int RightY;
  while(true) {
    RightX = vexRT[Ch1]; // Setting thses variables once per thread cycle helps keep math consistent.
    RightY = vexRT[Ch2];

    // Arcade drive code, somewhat obsolete this year since we aren't driving around, but good code to have for the future.
    // Right joystick controls all driving

    if(RightY > threshold) { // Forwards
      motor[LeftDrive] = (RightY + RightX)^2/127;
      motor[RightDrive] = (RightY - RightX)^2/127;
    }  else if(RightY < -threshold) { // Backwards
      motor[LeftDrive] = (RightY + RightX)^2/127;
      motor[RightDrive] = (RightY - RightX)^2/127;
    }  else if((abs(RightX) > threshold) && (abs(RightY) < threshold)) { // Turning in Place
      motor[LeftDrive] = RightX;
      motor[RightDrive] = (-1 * RightX);
    }  else { // If no controls held, disable motors
      motor[LeftDrive] = 0;
      motor[RightDrive] = 0;
    }
  }
}

task Arm() {
  int LeftX;
  int LeftY;
  while(true) {

    LeftX = vexRT[Ch4]; // Setting thses variables once per thread cycle helps keep math consistent.
    LeftY = vexRT[Ch3];

    if(vexRT[Btn6U]) { // While holding button 6U, small motor in port 3 is controlled by left joystick's Y axis.
      if((LeftY > threshold) && SensorValue[sMotor1f]) {
        motor[sMotor1] = LeftY;
      } else if((LeftY < -threshold) && SensorValue[sMotor1r]) {
        motor[sMotor1] = LeftY;
      } else {
        motor[sMotor1] = 0;
      }
    } else {
      motor[sMotor1] = 0;
    }

    if(vexRT[Btn6D]) {  // While holding button 6U, small motor in port 8 is controlled by left joystick's Y axis.
      if((LeftY > threshold) && SensorValue[sMotor2f]) {
        motor[sMotor2] = LeftY;
      } else if((LeftY < -threshold) && SensorValue[sMotor2r]) {
        motor[sMotor2] = LeftY;
      } else {
        motor[sMotor2] = 0;
      }
    } else {
      motor[sMotor2] = 0;
    }


    if(vexRT[Btn5U]) { // While holding button 5U, servo in port 4 is controlled by left joystick's Y axis, and it will stay in its position when you release the button.
      motor[servo1] = LeftY;
    }
    if(vexRT[Btn5D]) { // While holding button 5D, servo in port 5 is controlled by left joystick's Y axis, and it will stay in its position when you release the button.
      motor[servo2] = LeftY;
    }

    if(vexRT[Btn7L]) { // When you press button 7L, servo in port 6 turns completely in one direction, 7R puts it in the opposite, and 7U puts it in the middle.
      motor[servo3] = -128;
    } else if(vexRT[Btn7U]) {
      motor[servo3] = 0;
    } else if(vexRT[Btn7R]) {
      motor[servo3] = 127;
    }

    if(vexRT[Btn8L]) { // When you press button 8L, servo in port 7 turns completely in one direction, 8R puts it in the opposite, and 8U puts it in the middle.
      motor[servo4] = -128;
    } else if(vexRT[Btn8U]) {
      motor[servo4] = 0;
    } else if(vexRT[Btn8R]) {
      motor[servo4] = 127;
    }
  }
}
task main() {
  StartTask(Drive);
  StartTask(Arm);
  int on = 1;
  while(on){}; // Keeps robot from auto-terminating.
}
